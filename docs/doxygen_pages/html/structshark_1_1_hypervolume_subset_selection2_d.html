<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>shark::HypervolumeSubsetSelection2D Struct Reference</title>
<script type="text/javaScript" src="search/search.js"></script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
<script src="../../mlstyle.js"></script>
<link href="../css/besser.css" rel="stylesheet" type="text/css"/>
</head>
<!-- pretty cool: each body gets an id tag which is the basename of the web page  -->
<!--              and allows for page-specific CSS. this is client-side scripted, -->
<!--              so the id will not yet show up in the served source code -->
<script type="text/javascript">
    jQuery(document).ready(function () {
        var url = jQuery(location).attr('href');
        var pname = url.substr(url.lastIndexOf("/")+1, url.lastIndexOf(".")-url.lastIndexOf("/")-1);
        jQuery('#this_url').html('<strong>' + pname + '</strong>');
        jQuery('body').attr('id', pname);
    });
</script>
<body>
    <div id="shark_old">
        <div id="wrap">
            <div id="header">
                <div id="site-name"><a href="../../sphinx_pages/build/html/index.html">Shark machine learning library</a></div>
                <ul id="nav">
                    <li >
                        <a href="../../sphinx_pages/build/html/rest_sources/installation.html">Installation</a>
                    </li>
		    <li >
                        <a href="../../sphinx_pages/build/html/rest_sources/tutorials/tutorials.html">Tutorials</a>
                    </li>
		    <li >
                        <a href="../../sphinx_pages/build/html/rest_sources/benchmark.html">Benchmarks</a>
                    </li>
                    <li class="active">
                        <a href="classes.html">Documentation</a>
                        <ul>
                            <li class="first"></li>
                            <li><a href="../../sphinx_pages/build/html/rest_sources/quickref/quickref.html">Quick references</a></li>
                            <li><a href="classes.html">Class list</a></li>
                            <li class="last"><a href="group__shark__globals.html">Global functions</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>
<div id="doxywrapper">
<!--
    <div id="global_doxytitle">Doxygen<br>Documentation:</div>
-->
    <div id="navrow_wrapper">
<!-- Generated by Doxygen 1.9.8 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceshark.html">shark</a></li><li class="navelem"><a class="el" href="structshark_1_1_hypervolume_subset_selection2_d.html">HypervolumeSubsetSelection2D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="structshark_1_1_hypervolume_subset_selection2_d-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">shark::HypervolumeSubsetSelection2D Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of the exact hypervolume subset selection algorithm in 2 dimensions.  
 <a href="structshark_1_1_hypervolume_subset_selection2_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_hypervolume_subset_selection2_d_8h_source.html">shark/Algorithms/DirectSearch/Operators/Hypervolume/HypervolumeSubsetSelection2D.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa0aa8bb2bc003bc32d6a636895009ae4" id="r_aa0aa8bb2bc003bc32d6a636895009ae4"><td class="memTemplParams" colspan="2">template&lt;typename Set , typename SelectedSet , typename <a class="el" href="_c_svm_linear_8cpp.html#ab106d665148183a2dc94dcf8716c9203">VectorType</a> &gt; </td></tr>
<tr class="memitem:aa0aa8bb2bc003bc32d6a636895009ae4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structshark_1_1_hypervolume_subset_selection2_d.html#aa0aa8bb2bc003bc32d6a636895009ae4">operator()</a> (Set const &amp;points, SelectedSet &amp;selected, std::size_t k, <a class="el" href="_c_svm_linear_8cpp.html#ab106d665148183a2dc94dcf8716c9203">VectorType</a> const &amp;refPoint)</td></tr>
<tr class="memdesc:aa0aa8bb2bc003bc32d6a636895009ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm. While this algorithm in general accepts fronts with dominated points in it, the caller has to ensure that after domination checks there are at least as many points left as there are to select. The Algorithm will throw an exception otherwise.  <br /></td></tr>
<tr class="separator:aa0aa8bb2bc003bc32d6a636895009ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fe369d85589e88caa8fde88615d253" id="r_a52fe369d85589e88caa8fde88615d253"><td class="memTemplParams" colspan="2">template&lt;typename Set , typename SelectedSet &gt; </td></tr>
<tr class="memitem:a52fe369d85589e88caa8fde88615d253"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structshark_1_1_hypervolume_subset_selection2_d.html#a52fe369d85589e88caa8fde88615d253">operator()</a> (Set const &amp;points, SelectedSet &amp;selected, std::size_t k)</td></tr>
<tr class="memdesc:a52fe369d85589e88caa8fde88615d253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm.  <br /></td></tr>
<tr class="separator:a52fe369d85589e88caa8fde88615d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the exact hypervolume subset selection algorithm in 2 dimensions. </p>
<p>This algorithm solves the problem of selecting a subset of points with largest hypervolume in 2D. The algorithm has complexity n (k+log(n))</p>
<p>While this algorithm accepts fronts with dominated points in it, the caller has to ensure that after domination checks there are at least as many points left as there are to select. The Algorithm will throw an exception otherwise.</p>
<p>This can easily be ensured by removing the nondominated points prior to calling this function.</p>
<p>The algorithm is described in: Bringmann, Karl, Tobias Friedrich, and Patrick Klitzke. "Two-dimensional subset selection for hypervolume and epsilon-indicator." Proceedings of the 2014 conference on Genetic and evolutionary computation. ACM, 2014. <br  />
 (although it is not very helpful) </p>

<p class="definition">Definition at line <a class="el" href="_hypervolume_subset_selection2_d_8h_source.html#l00054">54</a> of file <a class="el" href="_hypervolume_subset_selection2_d_8h_source.html">HypervolumeSubsetSelection2D.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a52fe369d85589e88caa8fde88615d253" name="a52fe369d85589e88caa8fde88615d253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fe369d85589e88caa8fde88615d253">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Set , typename SelectedSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shark::HypervolumeSubsetSelection2D::operator() </td>
          <td>(</td>
          <td class="paramtype">Set const &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SelectedSet &amp;&#160;</td>
          <td class="paramname"><em>selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the algorithm. </p>
<p>This version does not use a reference point. instead the extreme points are always kept which implicitely defines a reference point that after domination checks there are at least as many points left as there are to select. The Algorithm will throw an exception otherwise.</p>
<p>This can easily be ensured by removing the nondominated points prior to calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The set \(S\) of points to select </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected</td><td>set of the same size as the set of points indicating whether the point is selected (1) or not (0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of points to select, must be larger or equal 2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_hypervolume_subset_selection2_d_8h_source.html#l00290">290</a> of file <a class="el" href="_hypervolume_subset_selection2_d_8h_source.html">HypervolumeSubsetSelection2D.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h.html#adce1f80097c69010f5eab2618fa2e971">SHARK_RUNTIME_CHECK</a>, and <a class="el" href="_exception_8h.html#a42a6a50e4d06c00d60fbca5333f40768">SIZE_CHECK</a>.</p>

</div>
</div>
<a id="aa0aa8bb2bc003bc32d6a636895009ae4" name="aa0aa8bb2bc003bc32d6a636895009ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aa8bb2bc003bc32d6a636895009ae4">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Set , typename SelectedSet , typename <a class="el" href="_c_svm_linear_8cpp.html#ab106d665148183a2dc94dcf8716c9203">VectorType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shark::HypervolumeSubsetSelection2D::operator() </td>
          <td>(</td>
          <td class="paramtype">Set const &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SelectedSet &amp;&#160;</td>
          <td class="paramname"><em>selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_svm_linear_8cpp.html#ab106d665148183a2dc94dcf8716c9203">VectorType</a> const &amp;&#160;</td>
          <td class="paramname"><em>refPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the algorithm. While this algorithm in general accepts fronts with dominated points in it, the caller has to ensure that after domination checks there are at least as many points left as there are to select. The Algorithm will throw an exception otherwise. </p>
<p>This can easily be ensured by removing the nondominated points prior to calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The set \(S\) of points to select </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected</td><td>set of the same size as the set of points indicating whether the point is selected (1) or not (0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of points to select. Must be lrger than 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refPoint</td><td>The reference point \(\vec{r} \in \mathbb{R}^2\) for the hypervolume calculation, needs to fulfill: \( \forall s \in S: s \preceq \vec{r}\). . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_hypervolume_subset_selection2_d_8h_source.html#l00256">256</a> of file <a class="el" href="_hypervolume_subset_selection2_d_8h_source.html">HypervolumeSubsetSelection2D.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h.html#adce1f80097c69010f5eab2618fa2e971">SHARK_RUNTIME_CHECK</a>, and <a class="el" href="_exception_8h.html#a42a6a50e4d06c00d60fbca5333f40768">SIZE_CHECK</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/shark/Algorithms/DirectSearch/Operators/Hypervolume/<a class="el" href="_hypervolume_subset_selection2_d_8h_source.html">HypervolumeSubsetSelection2D.h</a></li>
</ul>
</div><!-- contents -->
</div>
</body>
</html>
